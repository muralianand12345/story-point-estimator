<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Test Client</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .panel h3 {
            margin-top: 0;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        label {
            display: block;
            margin: 10px 0 5px;
            font-weight: bold;
        }
        input, select, button {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        button.danger {
            background-color: #e74c3c;
        }
        button.danger:hover {
            background-color: #c0392b;
        }
        button.success {
            background-color: #2ecc71;
        }
        button.success:hover {
            background-color: #27ae60;
        }
        .vote-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .vote-card {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px 0;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .vote-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .vote-card.selected {
            background-color: #3498db;
            color: white;
            border-color: #2980b9;
        }
        .log-area {
            grid-column: 1 / span 2;
            height: 250px;
            overflow-y: auto;
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
        }
        .log-area div {
            margin-bottom: 5px;
            border-bottom: 1px solid #34495e;
            padding-bottom: 5px;
        }
        .log-area .error {
            color: #e74c3c;
        }
        .log-area .success {
            color: #2ecc71;
        }
        .log-area .info {
            color: #3498db;
        }
        .log-area .warning {
            color: #f39c12;
        }
        .user-list {
            padding: 0;
            list-style-type: none;
        }
        .user-list li {
            padding: 8px;
            background-color: white;
            margin-bottom: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .user-list button {
            width: auto;
            padding: 5px 10px;
            margin: 0;
        }
        .user-host {
            background-color: #f8f4e5;
            border-left: 3px solid #f1c40f;
        }
        .hidden {
            display: none;
        }
        .votes-display {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .vote-result {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        .vote-result h4 {
            margin: 0;
            color: #7f8c8d;
        }
        .vote-result .value {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <h1>WebSocket Test Client</h1>
    
    <div class="panel">
        <h3>Connection</h3>
        <label for="ws-url">WebSocket URL:</label>
        <input type="text" id="ws-url" value="ws://localhost:8000/ws" />
        
        <div id="connection-inputs">
            <label for="room-id">Room ID:</label>
            <input type="text" id="room-id" placeholder="Enter room ID" />
            
            <label for="user-id">User ID:</label>
            <input type="text" id="user-id" placeholder="Enter user ID" />
            
            <button id="connect-btn">Connect</button>
        </div>
        
        <div id="connection-status" class="hidden">
            <p>Status: <span id="status-text">Disconnected</span></p>
            <button id="disconnect-btn" class="danger">Disconnect</button>
        </div>
    </div>
    
    <div class="container">
        <div class="panel">
            <h3>Room Controls</h3>
            <div id="room-info" class="hidden">
                <p>Room ID: <span id="current-room-id"></span></p>
                <p>User ID: <span id="current-user-id"></span></p>
                <p>Current Issue: <span id="current-issue">No issue set</span></p>
                
                <div id="host-controls" class="hidden">
                    <label for="issue-input">Set Issue:</label>
                    <input type="text" id="issue-input" placeholder="Enter issue title" />
                    <button id="set-issue-btn" class="success">Set Issue</button>
                    
                    <button id="reveal-btn">Reveal Votes</button>
                    <button id="reset-btn">Reset Votes</button>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h3>Users</h3>
            <ul id="user-list" class="user-list">
                <!-- User list will be populated here -->
            </ul>
        </div>
        
        <div class="panel">
            <h3>Voting</h3>
            <div id="voting-area">
                <div id="vote-cards" class="vote-options">
                    <div class="vote-card" data-value="0">0</div>
                    <div class="vote-card" data-value="0.5">0.5</div>
                    <div class="vote-card" data-value="1">1</div>
                    <div class="vote-card" data-value="2">2</div>
                    <div class="vote-card" data-value="3">3</div>
                    <div class="vote-card" data-value="5">5</div>
                    <div class="vote-card" data-value="8">8</div>
                    <div class="vote-card" data-value="13">13</div>
                    <div class="vote-card" data-value="20">20</div>
                    <div class="vote-card" data-value="40">40</div>
                    <div class="vote-card" data-value="100">100</div>
                    <div class="vote-card" data-value="?">?</div>
                    <div class="vote-card" data-value="Pass">Pass</div>
                </div>
                <p id="vote-status">You haven't voted yet</p>
            </div>
        </div>
        
        <div class="panel hidden" id="results-panel">
            <h3>Results</h3>
            <div id="vote-results" class="votes-display">
                <!-- Results will be populated here -->
            </div>
            
            <div id="vote-metrics" class="votes-display">
                <div class="vote-result">
                    <h4>Average</h4>
                    <div class="value" id="average-vote">0</div>
                </div>
                <div class="vote-result">
                    <h4>Median</h4>
                    <div class="value" id="median-vote">0</div>
                </div>
                <div class="vote-result">
                    <h4>Mode</h4>
                    <div class="value" id="mode-vote">0</div>
                </div>
                <div class="vote-result">
                    <h4>Total Votes</h4>
                    <div class="value" id="total-votes">0</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="panel">
        <h3>Event Log</h3>
        <div id="log" class="log-area">
            <!-- Log messages will be shown here -->
        </div>
    </div>

    <script>
        // DOM elements
        const wsUrlInput = document.getElementById('ws-url');
        const roomIdInput = document.getElementById('room-id');
        const userIdInput = document.getElementById('user-id');
        const connectBtn = document.getElementById('connect-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const connectionInputs = document.getElementById('connection-inputs');
        const connectionStatus = document.getElementById('connection-status');
        const statusText = document.getElementById('status-text');
        const roomInfo = document.getElementById('room-info');
        const currentRoomId = document.getElementById('current-room-id');
        const currentUserId = document.getElementById('current-user-id');
        const currentIssue = document.getElementById('current-issue');
        const hostControls = document.getElementById('host-controls');
        const issueInput = document.getElementById('issue-input');
        const setIssueBtn = document.getElementById('set-issue-btn');
        const revealBtn = document.getElementById('reveal-btn');
        const resetBtn = document.getElementById('reset-btn');
        const userList = document.getElementById('user-list');
        const voteCards = document.querySelectorAll('.vote-card');
        const voteStatus = document.getElementById('vote-status');
        const resultsPanel = document.getElementById('results-panel');
        const voteResults = document.getElementById('vote-results');
        const averageVote = document.getElementById('average-vote');
        const medianVote = document.getElementById('median-vote');
        const modeVote = document.getElementById('mode-vote');
        const totalVotes = document.getElementById('total-votes');
        const logArea = document.getElementById('log');
        
        // State variables
        let socket = null;
        let roomId = '';
        let userId = '';
        let isHost = false;
        let isRevealed = false;
        let users = [];
        let votes = {};
        let selectedVote = null;

        // Event enum (must match server)
        const SocketEvent = {
            USER_JOINED: 'user-joined',
            USER_LEFT: 'user-left',
            HOST_CHANGED: 'host-changed',
            KICKED: 'kicked',
            KICK_USER: 'kick-user',
            LEAVE_ROOM: 'leave-room',
            SUBMIT_VOTE: 'submit-vote',
            REVEAL_VOTES: 'reveal-votes',
            RESET_VOTES: 'reset-votes',
            VOTES_UPDATED: 'votes-updated',
            ISSUE_UPDATED: 'issue-updated'
        };

        // Event listeners
        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);
        setIssueBtn.addEventListener('click', setIssue);
        revealBtn.addEventListener('click', revealVotes);
        resetBtn.addEventListener('click', resetVotes);

        voteCards.forEach(card => {
            card.addEventListener('click', () => {
                if (isRevealed) return;

                const value = card.dataset.value;
                voteCards.forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selectedVote = value;
                submitVote(value);
            });
        });

        // WebSocket functions
        function connect() {
            const wsUrl = wsUrlInput.value;
            roomId = roomIdInput.value;
            userId = userIdInput.value;

            if (!wsUrl || !roomId || !userId) {
                logMessage('Please fill in all required fields', 'error');
                return;
            }

            try {
                socket = new WebSocket(wsUrl);
                
                socket.onopen = () => {
                    logMessage('WebSocket connection established', 'success');
                    statusText.textContent = 'Connected';
                    
                    // Send initialization message
                    sendMessage({
                        event: 'init',
                        userId: userId,
                        roomId: roomId,
                        payload: null
                    });
                    
                    // Update UI
                    connectionInputs.classList.add('hidden');
                    connectionStatus.classList.remove('hidden');
                    roomInfo.classList.remove('hidden');
                    currentRoomId.textContent = roomId;
                    currentUserId.textContent = userId;
                };
                
                socket.onmessage = handleMessage;
                
                socket.onclose = () => {
                    logMessage('WebSocket connection closed', 'warning');
                    resetUI();
                };
                
                socket.onerror = (error) => {
                    logMessage(`WebSocket error: ${error.message}`, 'error');
                    resetUI();
                };
            } catch (error) {
                logMessage(`Error creating WebSocket: ${error.message}`, 'error');
            }
        }

        function disconnect() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                sendMessage({
                    event: SocketEvent.LEAVE_ROOM,
                    userId: userId,
                    roomId: roomId,
                    payload: null
                });
                socket.close();
            }
            resetUI();
        }

        function resetUI() {
            statusText.textContent = 'Disconnected';
            connectionInputs.classList.remove('hidden');
            connectionStatus.classList.add('hidden');
            roomInfo.classList.add('hidden');
            hostControls.classList.add('hidden');
            resultsPanel.classList.add('hidden');
            userList.innerHTML = '';
            voteCards.forEach(c => c.classList.remove('selected'));
            socket = null;
            isHost = false;
            isRevealed = false;
            users = [];
            votes = {};
        }

        // Message handling
        function sendMessage(message) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(message));
                logMessage(`Sent: ${JSON.stringify(message)}`, 'info');
            } else {
                logMessage('Socket not connected, cannot send message', 'error');
            }
        }

        function handleMessage(event) {
            try {
                const message = JSON.parse(event.data);
                logMessage(`Received: ${JSON.stringify(message)}`, 'success');
                
                const { event: eventType, payload } = message;
                
                switch (eventType) {
                    case SocketEvent.USER_JOINED:
                        handleUserJoined(payload);
                        break;
                    case SocketEvent.USER_LEFT:
                        handleUserLeft(payload);
                        break;
                    case SocketEvent.HOST_CHANGED:
                        handleHostChanged(payload);
                        break;
                    case SocketEvent.KICKED:
                        handleKicked();
                        break;
                    case SocketEvent.VOTES_UPDATED:
                        handleVotesUpdated(payload);
                        break;
                    case SocketEvent.REVEAL_VOTES:
                        handleRevealVotes(payload);
                        break;
                    case SocketEvent.RESET_VOTES:
                        handleResetVotes();
                        break;
                    case SocketEvent.ISSUE_UPDATED:
                        handleIssueUpdated(payload);
                        break;
                    default:
                        logMessage(`Unhandled event: ${eventType}`, 'warning');
                }
            } catch (error) {
                logMessage(`Error parsing message: ${error.message}`, 'error');
            }
        }

        // Event handlers
        function handleUserJoined(payload) {
            logMessage(`User joined: ${payload.userId}`);
            // In a real app, we would fetch the updated user list
            // For this test, we'll simulate by adding the user
            users.push({ id: payload.userId, name: `User ${payload.userId.substr(0, 4)}` });
            updateUserList();
        }

        function handleUserLeft(userId) {
            logMessage(`User left: ${userId}`);
            users = users.filter(user => user.id !== userId);
            updateUserList();
        }

        function handleHostChanged(newHostId) {
            logMessage(`Host changed to: ${newHostId}`);
            isHost = (newHostId === userId);
            updateUserList();
            if (isHost) {
                hostControls.classList.remove('hidden');
            } else {
                hostControls.classList.add('hidden');
            }
        }

        function handleKicked() {
            logMessage('You have been kicked from the room', 'error');
            disconnect();
        }

        function handleVotesUpdated(updatedVotes) {
            votes = updatedVotes;
            logMessage(`Votes updated: ${Object.keys(votes).length} votes received`);
            
            // Update vote status
            const userVote = votes[userId];
            if (userVote) {
                voteStatus.textContent = `Your vote: ${userVote.value === null ? 'Pass' : userVote.value}`;
                // Highlight the selected card
                voteCards.forEach(card => {
                    if ((userVote.value === null && card.dataset.value === 'Pass') || 
                        card.dataset.value == userVote.value) {
                        card.classList.add('selected');
                    } else {
                        card.classList.remove('selected');
                    }
                });
            } else {
                voteStatus.textContent = `You haven't voted yet`;
                voteCards.forEach(card => card.classList.remove('selected'));
            }
            
            if (isRevealed) {
                updateResults();
            }
        }

        function handleRevealVotes(revealed) {
            isRevealed = revealed;
            if (revealed) {
                logMessage('Votes have been revealed');
                resultsPanel.classList.remove('hidden');
                updateResults();
                revealBtn.textContent = 'Hide Votes';
            } else {
                logMessage('Votes have been hidden');
                resultsPanel.classList.add('hidden');
                revealBtn.textContent = 'Reveal Votes';
            }
        }

        function handleResetVotes() {
            logMessage('Votes have been reset');
            votes = {};
            isRevealed = false;
            resultsPanel.classList.add('hidden');
            voteStatus.textContent = `You haven't voted yet`;
            voteCards.forEach(card => card.classList.remove('selected'));
            revealBtn.textContent = 'Reveal Votes';
        }

        function handleIssueUpdated(issue) {
            logMessage(`Issue updated: ${issue}`);
            currentIssue.textContent = issue || 'No issue set';
        }

        // UI Actions
        function updateUserList() {
            userList.innerHTML = '';
            users.forEach(user => {
                const isUserHost = isHost && user.id === userId;
                const li = document.createElement('li');
                li.className = isUserHost ? 'user-host' : '';
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = `${user.name} ${user.id === userId ? '(You)' : ''}${isUserHost ? ' (Host)' : ''}`;
                li.appendChild(nameSpan);
                
                if (isHost && user.id !== userId) {
                    const kickBtn = document.createElement('button');
                    kickBtn.textContent = 'Kick';
                    kickBtn.className = 'danger';
                    kickBtn.addEventListener('click', () => kickUser(user.id));
                    li.appendChild(kickBtn);
                }
                
                userList.appendChild(li);
            });
        }

        function updateResults() {
            // Clear previous results
            voteResults.innerHTML = '';
            
            // Process votes
            const voteValues = Object.values(votes)
                .map(v => v.value)
                .filter(v => v !== null);
                
            if (voteValues.length === 0) {
                // No numeric votes
                averageVote.textContent = 'N/A';
                medianVote.textContent = 'N/A';
                modeVote.textContent = 'N/A';
                totalVotes.textContent = '0';
                return;
            }
            
            // Calculate average
            const sum = voteValues.reduce((acc, val) => acc + val, 0);
            const avg = sum / voteValues.length;
            averageVote.textContent = avg.toFixed(1);
            
            // Calculate median
            const sorted = [...voteValues].sort((a, b) => a - b);
            const middle = Math.floor(sorted.length / 2);
            const median = sorted.length % 2 === 0
                ? (sorted[middle - 1] + sorted[middle]) / 2
                : sorted[middle];
            medianVote.textContent = median;
            
            // Calculate mode
            const frequency = {};
            voteValues.forEach(value => {
                frequency[value] = (frequency[value] || 0) + 1;
            });
            
            let maxFrequency = 0;
            let modes = [];
            
            for (const [value, count] of Object.entries(frequency)) {
                if (count > maxFrequency) {
                    maxFrequency = count;
                    modes = [value];
                } else if (count === maxFrequency) {
                    modes.push(value);
                }
            }
            
            modeVote.textContent = modes.join(', ');
            totalVotes.textContent = voteValues.length;
            
            // Display individual votes
            for (const [userId, vote] of Object.entries(votes)) {
                const voteDiv = document.createElement('div');
                voteDiv.className = 'vote-result';
                
                const userDiv = document.createElement('h4');
                const user = users.find(u => u.id === userId) || { name: `User ${userId.substr(0, 4)}` };
                userDiv.textContent = user.name + (userId === this.userId ? ' (You)' : '');
                
                const valueDiv = document.createElement('div');
                valueDiv.className = 'value';
                valueDiv.textContent = vote.value === null ? 'Pass' : vote.value;
                
                voteDiv.appendChild(userDiv);
                voteDiv.appendChild(valueDiv);
                voteResults.appendChild(voteDiv);
            }
        }

        // Action functions
        function setIssue() {
            const issue = issueInput.value.trim();
            if (!issue) return;
            
            sendMessage({
                event: SocketEvent.ISSUE_UPDATED,
                userId: userId,
                roomId: roomId,
                payload: issue
            });
            
            issueInput.value = '';
        }

        function submitVote(voteValue) {
            let value = voteValue;
            
            // Convert string to appropriate type
            if (value === 'Pass') {
                value = null;
            } else if (value !== '?') {
                value = parseFloat(value);
            }
            
            sendMessage({
                event: SocketEvent.SUBMIT_VOTE,
                userId: userId,
                roomId: roomId,
                payload: value
            });
        }

        function revealVotes() {
            sendMessage({
                event: SocketEvent.REVEAL_VOTES,
                userId: userId,
                roomId: roomId,
                payload: !isRevealed
            });
        }

        function resetVotes() {
            sendMessage({
                event: SocketEvent.RESET_VOTES,
                userId: userId,
                roomId: roomId,
                payload: null
            });
        }

        function kickUser(userIdToKick) {
            if (confirm(`Are you sure you want to kick user ${userIdToKick}?`)) {
                sendMessage({
                    event: SocketEvent.KICK_USER,
                    userId: userId,
                    roomId: roomId,
                    payload: userIdToKick
                });
            }
        }

        // Helper functions
        function logMessage(message, type = '') {
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logArea.appendChild(logEntry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        // Generate random IDs for easy testing
        function generateRandomId() {
            return Math.random().toString(36).substring(2, 10);
        }

        // Initialize with random IDs for easier testing
        roomIdInput.value = generateRandomId();
        userIdInput.value = generateRandomId();
    </script>
</body>
</html>